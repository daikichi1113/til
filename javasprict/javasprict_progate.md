# javascriptの基礎
文字列はシングルクォーテーション（ ' ）かダブルクォーテーション（ " ）で囲む。数値は囲まない。

文の最後はセミコロン（;）で終わる

# 変数
変数は、データ（値）の入れ物（箱）。箱の中に実際の値（文字列や数値など）が入っている。
変数はクォーテーションで囲みません。

## 変数の定義
let 変数名 = 値

右辺を左辺に代入する

## 変数のメリット
１）同じ値を繰り返し使える
２）変更に対応しやすい
３）値の意味がわかりやすい

## 変数の命名ルール
変数名（変数の名前）は自由に決めることができるが、できるだけ分かりやすい名前をつけるように！

良い例）英単語を用いる。２単語以上は大文字で区切る
悪い例）数字開始。ローマ字、日本語

## 変数の更新
定義する時と違って「let」は必要なく、「変数名 = 新しい値」と書けば値が変更される
プログラムは上から順に実行されるので、後で代入された値で変数の中身が更新される


# 定数
定数は値を更新することはできない

## 定数の定義
const 定数名 = 値

## 定数のメリット
定数のメリットは、「後から値を更新できない」ところ。一見不便に感じるかもしれないが、予期せぬ更新を防ぐことができ、より安全なコードを書くことができる。

# テンプレートリテラル
文字列の中に定数（変数）を埋め込む

## テンプレートリテラルの書き方
文字列の中で「${定数}」とする。文字列全体をバッククォーテーション（`）で囲む必要がある
バッククォーテーションの書き方　shift+@キー

# 条件分岐
## if文
if(条件式){
  処理;
} else if(条件式) {
  処理;
} else {
  処理;
}

条件式は、成り立つと「true」、成り立たなければ「false」という真偽値に置き換わる

## switch文
ある値によって処理を分岐する場合にswitch文を用いる

switch(条件の値 ※変数や定数など ) { 
  case 値1:
    「条件の値」が「値1」と同じ時の処理;
    break;
  :
  :
  :
  default:
    「条件の値」が「どの値とも異なる」場合の処理;
    break;
}

*分岐の数だけcaseを追加する

＊breakとはswitch文を終了する命令。breakがないと、合致したcaseの処理を行った後、その次のcaseの処理も実行してしまうので忘れないように。

# 比較演算子
## 大小を比べる
a < b, a <= b, a >= b, a > b

## 等しいかを調べる
a === b, a !== b

## かつ　または
かつ　a && b
または　a || b

# 繰り返し処理
## while文
while (条件式){
  処理
}

## for文
for (変数の定義;条件式;変数の更新){
  処理
}

# 配列
配列を定数に代入
const 定数名 = [値, 値, 値,...]

## インデックス番号
配列の要素の番号。０から始まる。
定数名[インデックス番号]　で取得。

## 配列の要素数
配列.length

# オブジェクト
オブジェクトは配列と同じく複数のデータをまとめて管理するのに用いられる。定数に代入することができる。

配列・・・複数の値を並べて管理
オブジェクト・・・それぞれの値にプロパティと呼ばれる名前をつけて管理。

## オブジェクトの作り方
{プロパティ1: 値1, プロパティ2: 値2}

## オブジェクトの代入
const 定数名 = {プロパティ1: 値1, プロパティ2: 値2}

## オブジェクトの値の取得
「オブジェクトを代入した定数（変数）名.プロパティ名」

## オブジェクトの値の更新
「オブジェクトを代入した定数（変数）名 = 新しい値」

## オブジェクトを要素に持つ配列
[ {プロパティ1: 値1, プロパティ2: 値2} ]

＊配列は要素ごとに縦に書くこともできる

配列の要素を取り出す　配列を代入した定数（変数）名[インデックス番号]
配列の要素のプロパティを取り出す　配列を代入した定数（変数）名[インデックス番号].プロパティ名

# undefined
undefined は特別な値で「値が定義されていない」という意味。(文字列ではない)
配列の存在しないインデックス番号の要素や、オブジェクトの存在しないプロパティの要素を取得しようとすると、undefined と出力される

# 複雑なオブジェクト
オブジェクトの中にオブジェクトが入っている場合
＊skillは１つのプロパティに複数の値が配列で入っている

const array = {name: a,
               age: 10,
               favorite: {food: "ラーメン",
                          drink: "コーラ",
                          ...}
               skill: ["javascript", "PHP", "Ruby"]
              }

呼び出し
array.favorite       結果 food: "ラーメン"
array.favorite.food  結果 ラーメン

# 関数
いくつかの処理をまとめたもの

## 関数の定義
const 定数名 = function() {
  まとめたい処理
}

＊function以下の式を定数名に代入している

## 関数の呼び出し
定数名();

## アロー関数
function()」の部分を「() =>」とする書き方。ES6から導入された。

例）
const 定数名 = function() {
  まとめたい処理
}

const 定数名 = () => {
  まとめたい処理
}

## オブジェクトと関数
オブジェクトの「値」の部分には、関数を用いることもできる

定義
const 定数名 = {
  プロパティ名: *ここから関数* () => {
    処理
  }
};

呼び出し
定数名.プロパティ名();

# 引数
関数に与える追加情報のようなもの。関数を呼び出すときに一緒に値を渡すことで、関数の中でその値を利用することができる。

## 引数を受け取る関数の定義と呼び出し
・定義
const 定数名 = function(引数名) {
  まとめたい処理
}

※アロー関数の場合
const 定数名 = (引数名) => {
  まとめたい処理
}

・呼び出し
定数名(引数名);

## 関数内で引数を使用する
const greet = (name) => {
  console.log(`私は${name}です`)
}

greet("小森")

※引数は関数の中で定数のように使える

## 複数の引数を受け取る関数
const greet = (name, age) => {
  console.log(`私は${name}です。年齢は${age}才です`)
}

greet("小森", 37)

※左から第一引数、第二引数...となる


# 戻り値（返り値）
関数の処理結果を呼び出し元で受け取る処理結果。関数が戻り値を返すという。

## return
「return 値」と書くことで、関数はその値を戻り値として返す.
なお、関数の処理を終了させる性質も持っているため、return以降の処理は実行されない。

## 戻り値を受け取る
const add = (a, b) => {
  return a + b;
  ↑②引数を代入して処理（戻り値は1+3で4）
}

const sum = add(1, 3)
            ↑①引数(1, 3)で関数addの呼び出し
            ↑③戻り値として②の結果(4)が返ってくる
      ↑左辺のsumに③の戻り値の4が代入される

console.log(sum); →　結果は４

## 様々な戻り値
真偽値を戻り値として受け取ることもできる。


# スコープ
それぞれの定数や変数の使用できる範囲のこと

## 関数の中の定数
関数内で定義した定数や変数は、その関数の中でしか使うことができない

## 関数の外の定数
関数の外で定義した定数や変数は、関数の中でも外でも使うことができる

## 関数以外のスコープ
ifやswitchなどの条件文、forやwhileなどの繰り返し文などの、中括弧「{}」を使う構文でもスコープを作る

## 最大値・最小値
Math.max
Math.min

# クラス
クラスとは、オブジェクトの設計図

## クラスの定義
class クラス名 {

}

＊クラス名の頭文字は大文字

## インスタンスの生成
クラスからオブジェクトを生成する 「new クラス名()」
「クラスから生成したオブジェクト」＝「インスタンス」

class クラス名 {

}
↑クラスの定義

const 定数名（インスタンス名） = new クラス名()
                             ↑インスタンスの生成
      ↑生成したインスタンスを定数に代入

## コンストラクタ
インスタンスを生成するときに実行したい処理や設定を追加するための機能

class クラス名 {
  constructor() {
    処理　*コンストラクタの処理はインスタンスが生成された直後に実行*
  }
}

## コンストラクタでプロパティと値を追加
コンストラクタの中で「this.プロパティ = 値」とすることで、生成されたインスタンスにプロパティと値を追加できる。

なお、インスタンス＝オブジェクトなので、コンストラクタの中で追加した値は「インスタンス.プロパティ」とすることでクラスの外で使用できる。

class クラス名 {
  constructor() {
    this.プロパティ = 値;
  }
}

const 定数名（インスタンス名） = new クラス名();

console.log(インスタンス名.プロパティ名) *結果は値*

## コンストラクタの引数（インスタンスごとに値を変える）
コンストラクタに引数として値を渡すには「new クラス名()」の括弧「( )」内に値を追加する。
以下の例では、文字列「"レオ"」という値が引数として渡され、コンストラクタ内では「name」として使うことができるようになる。

例）
class Animal {
  constructor(name, age) {
              ↑②引数を受ける
    this.name = name;
                ↑③②の引数nameの値
        ↑④this.nameにnameの値を代入
    this.age = age;
  }
}

const animal = new Animal("レオ", 3);
                ↑①インスタンス生成時に引数に値を渡す


## メソッド
クラスの重要な機能の1つ。そのインスタンスの「動作」のようなもの。

プロパティ：「名前」や「年齢」などの情報
メソッド　：挨拶をする」「値を計算する」などの処理のまとまり。

## メソッドの定義
メソッドはクラスの中で「メソッド名() {処理}」で定義する。関数に似ている。

class クラス名 {
  メソッド名() {
    処理
  }
}

## メソッドの呼び出し
メソッドは、そのクラスから生成したインスタンスに対して呼び出す。呼び出し方は「インスタンス.メソッド名()」

class クラス名 {
  メソッド名() {
    処理
  }
}

const 定数名（インスタンス名） = new クラス名();

インスタンス名.メソッド名();

## メソッド内でのメソッド呼び出し
メソッド内で「this.メソッド名()」とすることで、同じクラスの他のメソッドを使える

class Animal {
  greet() {
    console.log("こんにちは");
  }
  info() {
    this.greet();
  }
}

## メソッドの戻り値
メソッドでは、関数と同じように戻り値を用いることができる

例）

class Animal(name,age) {
  this.name: name,
  this.age: age,
  getHumanAge() {
    return this.age * 7
  }
}

const animal = new Animal(name, age)
                ↑インスタンスの生成
          ↑インスタンスを代入

const getHumanAge = animal.getHumanAge()
                    ↑animalインスタンスのgetHumanAge()メソッドの戻り値を代入


# クラスの継承
すでにあるクラスをもとに、新しくクラスを作成する方法のこと.

## 継承の書き方
class 子クラス extends 親クラス

子クラスは親クラスの全ての機能を引き継いでいるため、親クラスのメソッドを使うことができる
反対に、子クラスのメソッドは親クラスでは使えない

## 子クラスでのメソッド追加
継承して作成したクラスにも、これまでと同じようにメソッドを追加することができる。

## オーバーライド
親クラスと同じ名前のメソッドを子クラスに定義すると、子クラスのメソッドが優先される

## コンストラクタのオーバーライド
子クラスにプロパティを追加したい場合などに用いる。
コンストラクタをオーバーライドする際は1行目に「super()」と記述する必要がある。

class Animal {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

class Dog extends Animal {
  constructor(name, age, breed) {
    super(name, age); 　
      *super()でオーバーライド*
    this.breed = breed;
  }
}

# モジュールの組み合わせ
JavaScriptのコードを複数のファイルに分割し、それらを組み合わせる。
複数ファイルに分割することで、維持・更新のしやすいコードを書くことができる。

## ファイルの分割
それぞれのファイルを関連づけし、必要な値を渡す必要がある。

### export
クラスの定義の後で「export default クラス名」とする
そのクラスをエクスポート（出力）し、他のファイルへ渡すことができる

例）
*animal.js*

class Animal {

}
export default Animal;

### import
他のファイルで定義されているクラスを使用するにはインポート（読込）をする必要がある
用するファイルの先頭で「import クラス名 from "./ファイル名"」と書く
＊ファイル名の拡張子の「.js」は省略可能

例）
*dog.jp*

import Animal from "./animal"
                     ↑相対パスでファイルを指定

### 値のexport/import
文字列や数値や関数など、どんな値でもエクスポートが可能

例）
*sample1.js*
const text = "hello";
export default text;
               ↑定数をexport

*sample2.js*
import text from "./sample1";
console.log(text);

### export default（デフォルトエクスポート)
そのファイルがインポートされると自動的に「export default 値」の値がインポートされる。
そのためエクスポート時の値の名前と、インポート時の値の名前に違いがあっても問題ない。

ただし、デフォルトエクスポートは1ファイル1つの値のみ。

### 名前付きエクスポート
複数の値をエクスポートしたい場合に用いる

エクスポート時　export { 値1, 値2 }
インポート時　　import { 値1, 値2 } from "./ファイル名"

# パッケージ
公開されている便利なプログラム＝パッケージ。
JavaScriptの機能を使うことで、このパッケージを自分のプログラムの中に組み込んで使える

## パッケージのimport
import 定数名 from "パッケージ名";

インポートすればそのファイルでパッケージが使えるようになる。


# 配列を操作するメソッド
## pushメソッド
配列の最後に新しい要素を追加する

配列 = [要素1, 要素2, 要素3]
配列.push(要素4); *引数の値４が配列に追加される*

例）
const numbers = [1, 2, 3]
numbers.push(4);

## コールバック関数
メソッドの引数に入る関数のこと

## forEachメソッド
配列の中の要素を1つずつ取り出して、全ての要素に繰り返し同じ処理を行う

配列 = [要素1, 要素2, 要素3]
              ↓配列の要素が１つずつ引数として呼ばれる
配列.foreach((引数)=> {処理})
             ↑この部分はアロー関数。
              また、このアロー関数はforEachの引数である。※引数に入る関数＝「コールバック関数」

例）
const numbers = [1, 2, 3]
numbers.forEach((number)=> {
  consol.log(number);
  })
*結果*
１
２
３

## findメソッド
コールバック関数の処理部分に記述した条件式に合う「1つ目の要素」を配列の中から取り出す。
処理の返り値があるので、代入する定数（変数）を定義する。

### 例１：return
const numbers = [1, 3, 5, 7];

const findNumber = numbers.find((number) => {
                                  ↑配列numbersの値を引数にしたアロー関数
            ↑処理の返り値を定数に代入
  return number > 3; *条件式*
});

console.log(findNumber);

*結果*
5

### 例２：オブジェクトのプロパティを条件式に使用するreturn
const animals = [{id:1, name:"ライオン"}, {id:2, name:"ぞう"}]

const findAnimals = animals.find((animal) => {
  return animal.id === 1;
})

consol.log(findAnimals);

*結果*　ライオン

## filterメソッド
記述した条件に合う要素を「全て取り出して新しい配列を作成する」メソッド

### 例１：return
const numbers = [1, 3, 5, 7];

const findNumber = numbers.filter((number) => {
  return number > 3; *条件式*
});

console.log(findNumber);

*結果*
[5, 7]

### 例２：オブジェクトのプロパティを条件式に使用するreturn
const animals = [{id:1, name:"ライオン"}, {id:2, name:"ぞう"}, {id:3, name:"キリン"}]

const findAnimals = animals.filter((animal) => {
  return animal.id > 1;
})

consol.log(findAnimals);

*結果*　[{id:2, name:"ぞう"}, {id:3, name:"キリン"}]

## mapメソッド
配列内のすべての要素に処理を行い、その戻り値から新しい配列を作成する

### 例１：return
const numbers = [1, 3, 5];

const doubleNumber = numbers.map((number) => {
  return number * 2; *条件式*
});

console.log(doubleNumber);

*結果*
[2, 6, 10] *全ての要素を２倍

### 例２：オブジェクトのプロパティを条件式に使用するreturn
const names = [
  {firstName:komori, lastName:daigo},
  {firstName:komori, lastName:keio}
]

const fullName = names.map((name) => {
  return name.fiestName + name.lastName
})

console.log(fullName)

*結果*
["komoridaigo", "komorikeiko"]

# コールバック関数
JavaScriptでは引数に関数を渡すことができます。引数に渡される関数をコールバック関数と呼ぶ

関数名(引数);

例）
*callNameという関数*
const callName = () => {
  console.log("komori")
};

*仮引数callbackのcallという関数*
const call = (callback) => {
              ↑②関数callNameをcallbackに代入
  callback();
  ↑③関数callNameが代入された関数callbackを呼び出し
}

call(callName);
     ↑①引数に関数callNameを渡して関数callを呼び出し

## 関数の呼び出し方と渡し方
関数の呼び出し　関数名();
コールバック関数を渡す　関数名　*()を付けない*

## コールバック関数を直接定義する
### 引数で関数を定義する
関数を直接引数の中で定義することもできる

例）
*関数を引数の外で定義*
const callName = () => {
  console.log("komori")
};

const call = (callback) => {
  callback();
}

call(callName);

↓
*関数を引数の中で定義*
const call = (callback) => {
  callback();
}

call(callName = () => {
  console.log("komori")
});

## コールバック関数で引数を渡す



